import 'package:flutter_test/flutter_test.dart';
import 'package:mockito/mockito.dart';
import 'package:mockito/annotations.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import 'package:flutter_auth_template/presentation/providers/auth_provider.dart';
import 'package:flutter_auth_template/infrastructure/services/auth/auth_service.dart';
import 'package:flutter_auth_template/infrastructure/services/auth/oauth_service.dart';
import 'package:flutter_auth_template/core/storage/secure_storage_service.dart';
import 'package:flutter_auth_template/domain/entities/auth_state.dart';
import 'package:flutter_auth_template/data/models/auth_request.dart';
import 'package:flutter_auth_template/domain/entities/user.dart';
import 'package:flutter_auth_template/core/network/api_response.dart';

import 'auth_provider_test_fixed.mocks.dart';

@GenerateMocks([AuthService, OAuthService, SecureStorageService])
void main() {
  group('AuthNotifier Tests', () {
    late MockAuthService mockAuthService;
    late MockOAuthService mockOAuthService;
    late MockSecureStorageService mockSecureStorage;
    late AuthNotifier authNotifier;
    late ProviderContainer container;

    setUp(() {
      mockAuthService = MockAuthService();
      mockOAuthService = MockOAuthService();
      mockSecureStorage = MockSecureStorageService();

      // Setup common mock responses
      when(mockAuthService.isAuthenticated()).thenAnswer((_) async => false);
      when(mockOAuthService.isGoogleSignedIn()).thenAnswer((_) async => false);

      container = ProviderContainer(
        overrides: [
          authServiceProvider.overrideWithValue(mockAuthService),
          oauthServiceProvider.overrideWithValue(mockOAuthService),
          secureStorageServiceProvider.overrideWithValue(mockSecureStorage),
        ],
      );

      authNotifier = container.read(authStateProvider.notifier);
    });

    tearDown(() {
      container.dispose();
    });

    group('login', () {
      test('should update state to loading then authenticated on successful login', () async {
        // Arrange
        const email = 'test@example.com';
        const password = 'password123';
        final request = LoginRequest(email: email, password: password);

        final mockUser = User(
        id: '123',
        email: email,
        name: 'Test User',
        isEmailVerified: false,
        isTwoFactorEnabled: false,
        roles: ['user'],
        permissions: [],
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
      ),
          updatedAt: DateTime.now(),
        );

        final successResponse = ApiResponse.success(data: mockUser, message: 'Login successful');
        when(mockAuthService.login(any)).thenAnswer((_) async => successResponse);

        // Act
        final future = authNotifier.login(email, password);

        // Assert initial loading state
        expect(authNotifier.state, isA<Authenticating>());

        await future;

        // Assert final authenticated state
        expect(authNotifier.state, isA<Authenticated>());
        final authenticatedState = authNotifier.state as Authenticated;
        expect(authenticatedState.user.email, email);
      });

      test('should update state to error on failed login', () async {
        // Arrange
        const email = 'test@example.com';
        const password = 'wrongpassword';
        const errorMessage = 'Invalid credentials';

        final errorResponse = ApiResponse<User>.error(message: errorMessage, code: 'AUTH_ERROR');
        when(mockAuthService.login(any)).thenAnswer((_) async => errorResponse);

        // Act
        try {
          await authNotifier.login(email, password);
          fail('Expected exception to be thrown');
        } catch (e) {
          // Expected to throw
        }

        // Assert error state
        expect(authNotifier.state, isA<AuthError>());
        final errorState = authNotifier.state as AuthError;
        expect(errorState.message, errorMessage);
      });

      test('should handle login exception', () async {
        // Arrange
        const email = 'test@example.com';
        const password = 'password123';

        when(mockAuthService.login(any)).thenThrow(Exception('Network error'));

        // Act & Assert
        expect(() => authNotifier.login(email, password), throwsA(isA<Exception>()));

        // Wait for the async operation to complete
        await Future.delayed(Duration.zero);

        // State should remain authenticating since exception was thrown before response processing
        expect(authNotifier.state, isA<Authenticating>());
      });
    });

    group('register', () {
      test('should update state to loading then authenticated on successful registration', () async {
        // Arrange
        const email = 'newuser@example.com';
        const password = 'password123';
        const name = 'New User';

        final mockUser = User(
        id: '124',
        email: email,
        name: name,
        isEmailVerified: false,
        isTwoFactorEnabled: false,
        roles: ['user'],
        permissions: [],
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
      ),
          updatedAt: DateTime.now(),
        );

        final successResponse = ApiResponse.success(data: mockUser, message: 'Registration successful');
        when(mockAuthService.register(any)).thenAnswer((_) async => successResponse);

        // Act
        final future = authNotifier.register(email, password, name);

        // Assert initial loading state
        expect(authNotifier.state, isA<Authenticating>());

        await future;

        // Assert final authenticated state
        expect(authNotifier.state, isA<Authenticated>());
        final authenticatedState = authNotifier.state as Authenticated;
        expect(authenticatedState.user.email, email);
        expect(authenticatedState.user.name, name);
      });

      test('should update state to error on failed registration', () async {
        // Arrange
        const email = 'existing@example.com';
        const password = 'password123';
        const name = 'Test User';
        const errorMessage = 'Email already exists';

        final errorResponse = ApiResponse<User>.error(message: errorMessage, code: 'VALIDATION_ERROR');
        when(mockAuthService.register(any)).thenAnswer((_) async => errorResponse);

        // Act
        try {
          await authNotifier.register(email, password, name);
        } catch (e) {
          // Expected to throw
        }

        // Assert error state
        expect(authNotifier.state, isA<AuthError>());
        final errorState = authNotifier.state as AuthError;
        expect(errorState.message, errorMessage);
      });
    });

    group('logout', () {
      test('should update state to unauthenticated on successful logout', () async {
        // Arrange
        final mockUser = User(
        id: '123',
        email: 'test@example.com',
        name: 'Test User',
        isEmailVerified: false,
        isTwoFactorEnabled: false,
        roles: ['user'],
        permissions: [],
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
      ),
          updatedAt: DateTime.now(),
        );

        // Set initial authenticated state
        authNotifier.state = AuthState.authenticated(
          user: mockUser,
          accessToken: 'test-token'
        );

        final successResponse = ApiResponse<String>.success(data: 'Logged out successfully', message: 'Success');
        when(mockAuthService.logout()).thenAnswer((_) async => successResponse);
        when(mockOAuthService.isGoogleSignedIn()).thenAnswer((_) async => false);

        // Act
        await authNotifier.logout();

        // Assert unauthenticated state
        expect(authNotifier.state, isA<Unauthenticated>());
      });

      test('should still logout locally even if API call fails', () async {
        // Arrange
        final mockUser = User(
        id: '123',
        email: 'test@example.com',
        name: 'Test User',
        isEmailVerified: false,
        isTwoFactorEnabled: false,
        roles: ['user'],
        permissions: [],
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
      ),
          updatedAt: DateTime.now(),
        );

        // Set initial authenticated state
        authNotifier.state = AuthState.authenticated(
          user: mockUser,
          accessToken: 'test-token'
        );

        when(mockOAuthService.isGoogleSignedIn()).thenAnswer((_) async => false);
        final errorResponse = ApiResponse<String>.error(message: 'Network error', code: 'NETWORK_ERROR');
        when(mockAuthService.logout()).thenAnswer((_) async => errorResponse);

        // Act
        await authNotifier.logout();

        // Assert still logs out locally (logout method always sets to unauthenticated)
        expect(authNotifier.state, isA<Unauthenticated>());
      });
    });

    group('Provider Tests', () {
      test('authStateProvider should provide AuthNotifier', () {
        final notifier = container.read(authStateProvider.notifier);
        expect(notifier, isA<AuthNotifier>());
      });

      test('authStateProvider should have initial authenticating state', () async {
        // The notifier starts authenticating then quickly resolves to unauthenticated
        // when isAuthenticated() returns false. We need to check the initial state immediately.
        final state = container.read(authStateProvider);
        // Either authenticating (if caught during init) or unauthenticated (if init completed)
        expect(state, anyOf(isA<Authenticating>(), isA<Unauthenticated>()));

        // Wait for initialization to complete
        await Future.delayed(Duration.zero);

        // After initialization, should be unauthenticated since isAuthenticated returns false
        final finalState = container.read(authStateProvider);
        expect(finalState, isA<Unauthenticated>());
      });
    });
  });
}