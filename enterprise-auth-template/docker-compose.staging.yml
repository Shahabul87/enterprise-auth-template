# Docker Compose for Staging Environment
# Production-like environment for final testing before production deployment

version: '3.8'

services:
  # PostgreSQL Database (Staging)
  postgres:
    image: postgres:15-alpine
    container_name: enterprise_auth_postgres_staging
    restart: unless-stopped
    environment:
      POSTGRES_DB: ${POSTGRES_DB:-enterprise_auth_staging}
      POSTGRES_USER: ${POSTGRES_USER:-staging_user}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      POSTGRES_INITDB_ARGS: "--auth-host=md5"
    volumes:
      - postgres_staging_data:/var/lib/postgresql/data
      - ./database/staging-init:/docker-entrypoint-initdb.d:ro
      - ./database/backups:/backups
    networks:
      - staging_network
    command: >
      postgres
      -c ssl=on
      -c ssl_cert_file=/etc/ssl/certs/ssl-cert-snakeoil.pem
      -c ssl_key_file=/etc/ssl/private/ssl-cert-snakeoil.key
      -c max_connections=200
      -c shared_buffers=512MB
      -c effective_cache_size=1GB
      -c maintenance_work_mem=128MB
      -c checkpoint_completion_target=0.9
      -c wal_buffers=16MB
      -c default_statistics_target=100
      -c random_page_cost=1.1
      -c effective_io_concurrency=200
      -c work_mem=4MB
      -c min_wal_size=1GB
      -c max_wal_size=4GB
      -c log_statement=mod
      -c log_duration=on
      -c log_min_duration_statement=100ms
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER:-staging_user} -d ${POSTGRES_DB:-enterprise_auth_staging}"]
      interval: 10s
      timeout: 5s
      retries: 5
    deploy:
      resources:
        limits:
          memory: 1GB
        reservations:
          memory: 512MB

  # Redis Cache (Staging)
  redis:
    image: redis:7-alpine
    container_name: enterprise_auth_redis_staging
    restart: unless-stopped
    environment:
      - REDIS_REPLICATION_MODE=master
    volumes:
      - redis_staging_data:/data
      - ./redis/staging.conf:/usr/local/etc/redis/redis.conf:ro
    networks:
      - staging_network
    command: >
      redis-server /usr/local/etc/redis/redis.conf
      --appendonly yes
      --appendfsync everysec
      --maxmemory 1gb
      --maxmemory-policy allkeys-lru
      --timeout 300
      --tcp-keepalive 300
      --requirepass ${REDIS_PASSWORD:-staging_redis_password}
    healthcheck:
      test: ["CMD", "redis-cli", "--no-auth-warning", "-a", "${REDIS_PASSWORD:-staging_redis_password}", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5
    deploy:
      resources:
        limits:
          memory: 1GB
        reservations:
          memory: 256MB

  # FastAPI Backend (Staging)
  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
      target: production
    container_name: enterprise_auth_backend_staging
    restart: unless-stopped
    environment:
      DATABASE_URL: postgresql://${POSTGRES_USER:-staging_user}:${POSTGRES_PASSWORD}@postgres:5432/${POSTGRES_DB:-enterprise_auth_staging}
      REDIS_URL: redis://:${REDIS_PASSWORD:-staging_redis_password}@redis:6379/0
      SECRET_KEY: ${SECRET_KEY}
      JWT_SECRET_KEY: ${JWT_SECRET_KEY}
      JWT_ALGORITHM: ${JWT_ALGORITHM:-HS256}
      JWT_ACCESS_TOKEN_EXPIRE_MINUTES: ${JWT_ACCESS_TOKEN_EXPIRE_MINUTES:-30}
      JWT_REFRESH_TOKEN_EXPIRE_DAYS: ${JWT_REFRESH_TOKEN_EXPIRE_DAYS:-7}
      ENVIRONMENT: staging
      DEBUG: "false"
      LOG_LEVEL: ${LOG_LEVEL:-INFO}
      FRONTEND_URL: ${FRONTEND_URL}
      # Email configuration
      SMTP_HOST: ${SMTP_HOST}
      SMTP_PORT: ${SMTP_PORT:-587}
      SMTP_USER: ${SMTP_USER}
      SMTP_PASSWORD: ${SMTP_PASSWORD}
      SMTP_TLS: ${SMTP_TLS:-true}
      # OAuth configurations
      GOOGLE_CLIENT_ID: ${GOOGLE_CLIENT_ID}
      GOOGLE_CLIENT_SECRET: ${GOOGLE_CLIENT_SECRET}
      GITHUB_CLIENT_ID: ${GITHUB_CLIENT_ID}
      GITHUB_CLIENT_SECRET: ${GITHUB_CLIENT_SECRET}
      # Security configurations
      CORS_ORIGINS: ${CORS_ORIGINS}
      ALLOWED_HOSTS: ${ALLOWED_HOSTS}
      # Rate limiting
      RATE_LIMIT_ENABLED: "true"
      RATE_LIMIT_REQUESTS: ${RATE_LIMIT_REQUESTS:-100}
      RATE_LIMIT_WINDOW: ${RATE_LIMIT_WINDOW:-60}
      # Monitoring
      ENABLE_METRICS: "true"
      SENTRY_DSN: ${SENTRY_DSN}
    ports:
      - "127.0.0.1:8000:8000"  # Only bind to localhost for security
    volumes:
      - backend_staging_logs:/app/logs
      - ./backend/static:/app/static:ro
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    networks:
      - staging_network
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    deploy:
      replicas: 2
      resources:
        limits:
          memory: 1GB
          cpus: '0.8'
        reservations:
          memory: 512MB
          cpus: '0.4'
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.backend-staging.rule=Host(`staging-api.${DOMAIN}`)"
      - "traefik.http.routers.backend-staging.tls=true"
      - "traefik.http.services.backend-staging.loadbalancer.server.port=8000"

  # Next.js Frontend (Staging)
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile.prod
      target: production
      args:
        - NEXT_PUBLIC_API_URL=${NEXT_PUBLIC_API_URL}
        - NEXT_PUBLIC_APP_NAME=${NEXT_PUBLIC_APP_NAME:-Enterprise Auth Template (Staging)}
        - NEXT_PUBLIC_ENVIRONMENT=staging
        - NEXT_PUBLIC_SENTRY_DSN=${NEXT_PUBLIC_SENTRY_DSN}
    container_name: enterprise_auth_frontend_staging
    restart: unless-stopped
    environment:
      - NODE_ENV=production
      - NEXT_TELEMETRY_DISABLED=1
      - PORT=3000
    ports:
      - "127.0.0.1:3000:3000"  # Only bind to localhost for security
    depends_on:
      - backend
    networks:
      - staging_network
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000/api/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    deploy:
      replicas: 2
      resources:
        limits:
          memory: 512MB
          cpus: '0.5'
        reservations:
          memory: 256MB
          cpus: '0.25'
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.frontend-staging.rule=Host(`staging.${DOMAIN}`)"
      - "traefik.http.routers.frontend-staging.tls=true"
      - "traefik.http.services.frontend-staging.loadbalancer.server.port=3000"

  # Nginx Reverse Proxy with SSL
  nginx:
    image: nginx:1.24-alpine
    container_name: enterprise_auth_nginx_staging
    restart: unless-stopped
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/staging.conf:/etc/nginx/conf.d/default.conf:ro
      - ./nginx/nginx-staging.conf:/etc/nginx/nginx.conf:ro
      - ./nginx/ssl:/etc/nginx/ssl:ro
      - nginx_staging_logs:/var/log/nginx
      - ./nginx/html:/usr/share/nginx/html:ro
    depends_on:
      - backend
      - frontend
    networks:
      - staging_network
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost/health"]
      interval: 30s
      timeout: 10s
      retries: 3
    deploy:
      resources:
        limits:
          memory: 256MB
        reservations:
          memory: 128MB
    labels:
      - "traefik.enable=false"  # Nginx handles external traffic

  # Traefik Load Balancer (Alternative to nginx)
  traefik:
    image: traefik:v3.0
    container_name: enterprise_auth_traefik_staging
    restart: unless-stopped
    command:
      - "--api.dashboard=true"
      - "--api.debug=false"
      - "--providers.docker=true"
      - "--providers.docker.exposedbydefault=false"
      - "--entrypoints.web.address=:80"
      - "--entrypoints.websecure.address=:443"
      - "--certificatesresolvers.letsencrypt.acme.tlschallenge=true"
      - "--certificatesresolvers.letsencrypt.acme.email=${ACME_EMAIL}"
      - "--certificatesresolvers.letsencrypt.acme.storage=/letsencrypt/acme.json"
      - "--certificatesresolvers.letsencrypt.acme.caserver=${ACME_SERVER:-https://acme-staging-v02.api.letsencrypt.org/directory}"
      - "--log.level=${TRAEFIK_LOG_LEVEL:-INFO}"
      - "--accesslog=true"
    ports:
      - "80:80"
      - "443:443"
      - "127.0.0.1:8080:8080"  # Dashboard - localhost only
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
      - letsencrypt_staging:/letsencrypt
      - traefik_staging_logs:/var/log/traefik
    networks:
      - staging_network
    profiles:
      - traefik
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.dashboard.rule=Host(`traefik-staging.${DOMAIN}`)"
      - "traefik.http.routers.dashboard.tls=true"
      - "traefik.http.routers.dashboard.service=api@internal"

  # Prometheus Monitoring
  prometheus:
    image: prom/prometheus:v2.45.0
    container_name: enterprise_auth_prometheus_staging
    restart: unless-stopped
    volumes:
      - ./monitoring/prometheus-staging.yml:/etc/prometheus/prometheus.yml:ro
      - ./monitoring/rules:/etc/prometheus/rules:ro
      - prometheus_staging_data:/prometheus
    networks:
      - staging_network
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      - '--web.console.libraries=/etc/prometheus/console_libraries'
      - '--web.console.templates=/etc/prometheus/consoles'
      - '--storage.tsdb.retention.time=30d'
      - '--web.enable-lifecycle'
      - '--web.external-url=http://prometheus-staging.${DOMAIN}'
    deploy:
      resources:
        limits:
          memory: 512MB
        reservations:
          memory: 256MB
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.prometheus-staging.rule=Host(`prometheus-staging.${DOMAIN}`)"
      - "traefik.http.services.prometheus-staging.loadbalancer.server.port=9090"

  # Grafana Visualization
  grafana:
    image: grafana/grafana-oss:10.0.0
    container_name: enterprise_auth_grafana_staging
    restart: unless-stopped
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=${GRAFANA_PASSWORD}
      - GF_SECURITY_ADMIN_USER=${GRAFANA_USER:-admin}
      - GF_SERVER_ROOT_URL=http://grafana-staging.${DOMAIN}
      - GF_INSTALL_PLUGINS=grafana-piechart-panel,grafana-clock-panel
      - GF_SECURITY_COOKIE_SECURE=true
      - GF_SECURITY_COOKIE_SAMESITE=strict
      - GF_USERS_ALLOW_SIGN_UP=false
      - GF_ANALYTICS_REPORTING_ENABLED=false
      - GF_ANALYTICS_CHECK_FOR_UPDATES=false
    volumes:
      - grafana_staging_data:/var/lib/grafana
      - ./monitoring/grafana/staging-dashboards:/var/lib/grafana/dashboards:ro
      - ./monitoring/grafana/provisioning:/etc/grafana/provisioning:ro
    depends_on:
      - prometheus
    networks:
      - staging_network
    deploy:
      resources:
        limits:
          memory: 512MB
        reservations:
          memory: 256MB
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.grafana-staging.rule=Host(`grafana-staging.${DOMAIN}`)"
      - "traefik.http.services.grafana-staging.loadbalancer.server.port=3000"

  # Elasticsearch for Logs (Staging)
  elasticsearch:
    image: docker.elastic.co/elasticsearch/elasticsearch:8.11.0
    container_name: enterprise_auth_elasticsearch_staging
    restart: unless-stopped
    environment:
      - node.name=elasticsearch-staging
      - cluster.name=staging-cluster
      - discovery.type=single-node
      - xpack.security.enabled=true
      - ELASTIC_PASSWORD=${ELASTIC_PASSWORD}
      - "ES_JAVA_OPTS=-Xms2g -Xmx2g"
      - xpack.monitoring.collection.enabled=true
    ulimits:
      memlock:
        soft: -1
        hard: -1
    volumes:
      - elasticsearch_staging_data:/usr/share/elasticsearch/data
      - ./elasticsearch/staging-config:/usr/share/elasticsearch/config/elasticsearch.yml:ro
    networks:
      - staging_network
    deploy:
      resources:
        limits:
          memory: 4GB
        reservations:
          memory: 2GB
    profiles:
      - logging

  # Kibana for Log Visualization
  kibana:
    image: docker.elastic.co/kibana/kibana:8.11.0
    container_name: enterprise_auth_kibana_staging
    restart: unless-stopped
    environment:
      - ELASTICSEARCH_HOSTS=http://elasticsearch:9200
      - ELASTICSEARCH_USERNAME=kibana_system
      - ELASTICSEARCH_PASSWORD=${KIBANA_PASSWORD}
      - SERVER_NAME=kibana-staging.${DOMAIN}
      - SERVER_PUBLICBASEURL=http://kibana-staging.${DOMAIN}
    depends_on:
      - elasticsearch
    networks:
      - staging_network
    deploy:
      resources:
        limits:
          memory: 1GB
        reservations:
          memory: 512MB
    profiles:
      - logging
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.kibana-staging.rule=Host(`kibana-staging.${DOMAIN}`)"
      - "traefik.http.services.kibana-staging.loadbalancer.server.port=5601"

  # Logstash for Log Processing
  logstash:
    image: docker.elastic.co/logstash/logstash:8.11.0
    container_name: enterprise_auth_logstash_staging
    restart: unless-stopped
    volumes:
      - ./logging/logstash/staging-config:/usr/share/logstash/pipeline:ro
      - ./logging/logstash/staging-settings:/usr/share/logstash/config:ro
      - backend_staging_logs:/var/log/backend:ro
      - nginx_staging_logs:/var/log/nginx:ro
    environment:
      - "LS_JAVA_OPTS=-Xms1g -Xmx1g"
      - ELASTICSEARCH_HOST=elasticsearch:9200
      - ELASTICSEARCH_USERNAME=logstash_writer
      - ELASTICSEARCH_PASSWORD=${LOGSTASH_PASSWORD}
    depends_on:
      - elasticsearch
    networks:
      - staging_network
    deploy:
      resources:
        limits:
          memory: 2GB
        reservations:
          memory: 1GB
    profiles:
      - logging

  # Backup Service
  backup:
    image: postgres:15-alpine
    container_name: enterprise_auth_backup_staging
    restart: no
    volumes:
      - ./database/backups:/backups
      - ./scripts/backup.sh:/backup.sh:ro
    environment:
      - PGHOST=postgres
      - PGDATABASE=${POSTGRES_DB:-enterprise_auth_staging}
      - PGUSER=${POSTGRES_USER:-staging_user}
      - PGPASSWORD=${POSTGRES_PASSWORD}
    depends_on:
      - postgres
    networks:
      - staging_network
    command: ["sh", "/backup.sh"]
    profiles:
      - backup

networks:
  staging_network:
    driver: bridge
    name: enterprise_auth_staging_network
    ipam:
      driver: default
      config:
        - subnet: 172.22.0.0/16
          gateway: 172.22.0.1

volumes:
  postgres_staging_data:
    driver: local
    name: enterprise_auth_postgres_staging_data
  redis_staging_data:
    driver: local
    name: enterprise_auth_redis_staging_data
  prometheus_staging_data:
    driver: local
    name: enterprise_auth_prometheus_staging_data
  grafana_staging_data:
    driver: local
    name: enterprise_auth_grafana_staging_data
  elasticsearch_staging_data:
    driver: local
    name: enterprise_auth_elasticsearch_staging_data
  backend_staging_logs:
    driver: local
    name: enterprise_auth_backend_staging_logs
  nginx_staging_logs:
    driver: local
    name: enterprise_auth_nginx_staging_logs
  traefik_staging_logs:
    driver: local
    name: enterprise_auth_traefik_staging_logs
  letsencrypt_staging:
    driver: local
    name: enterprise_auth_letsencrypt_staging